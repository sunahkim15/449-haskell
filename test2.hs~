import Data.List


intToChar :: Int -> Char
intToChar 0 = 'A'
intToChar 1 = 'B'
intToChar 2 = 'C'
intToChar 3 = 'D'
intToChar 4 = 'E'
intToChar 5 = 'F'
intToChar 6 = 'G'
intToChar 7 = 'H'
intToChar x = 'Z'

charToInt :: Char -> Int
charToInt 'A' = 0
charToInt 'B' = 1
charToInt 'C' = 2
charToInt 'D' = 3
charToInt 'E' = 4
charToInt 'F' = 5
charToInt 'G' = 6
charToInt 'H' = 7
charToInt x = 10

eliminate :: Maybe a -> a
eliminate (Just a) = a

deleteN :: Int -> [a] -> [a]
deleteN _ []     = []
deleteN i (a:as)
   | i == 0    = as
   | otherwise = a : deleteN (i-1) as

penalties = [[10,1,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10],
             [10,10,10,10,10,10,10,10]]
tasks = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']


 
subTreeLB :: [Char] -> Char -> Int -> Int -> Int -> Int
subTreeLB  remaining previous currentMachine currentCost minLowerBound =
   minimum [minLowerBound, subTreeLB]
   where   subTreeLB = minimum [x + y + z
                               |x <- [currentCost],
                                y <- [someList],
                                z <- [replaceWithMachinePenaltiesAndShit]]
           someList = [subTreeLB
                       ( deleteN ( eliminate ( elemIndex (x) (remaining) ) ) (remaining))
                       (x)
                       (currentMachine + 1)
                       (currentCost + (penalties !! (machine) !! (charToInt (remaining !! 0))) --this line is where we will add in too-near penalties and stuff later
                       
                       
           replaceWithMachinePenaltiesAndShit = 5
           

main = do
  let y = 5
  print y
        
